/**
 * groov Manage
 * _groov_ Manage REST API ==================================================================  The _groov_ Manage REST API provides secure access to the I/O on the rack.  The REST API allows clients to store and retrieve files for use by Node-RED, the Control Engine, _groov_ Manage, and other REST clients.  Authentication ------------------------------------------------------------------  Each request is authenticated by means of an API key.  API keys are assigned to each user within _groov_ Manage.  Example Request ------------------------------------------------------------------  Using *curl* to request the list of modules plugged into the rack at hostname *opto-01-02-03* with an API Key of *TZC2TAPxs2jyqU9xRKEoSRNVEL3qfAsw*:      curl -k -H apiKey:TZC2TAPxs2jyqU9xRKEoSRNVEL3qfAsw        https://opto-01-02-03/manage/api/v1/io/local/modules/type  Example Response:      {       \"types\": [         {           \"index\": 0,           \"type\": \"0xA0000003\",           \"name\": \"GRV-OVMALC-8\"         },         {           \"index\": 1,           \"type\": \"0x60000002\",           \"name\": \"GRV-IV-24\"         },         {           \"index\": 2,           \"type\": \"0x00000000\",           \"name\": \"\"         },         ...etc...       ]     } 
 *
 * OpenAPI spec version: 1.3.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import https = require('https');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost/manage';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AbstractChannelRead {
    /**
    * Discriminator for the model type. Either 'AnalogChannelRead' or 'DigitalChannelRead'.
    */
    'modelType': string;
    /**
    * The index of the module, between 0 and 15.
    */
    'moduleIndex': number;
    /**
    * The index of the channel, between 0 and one less than the number of channels on the current module.
    */
    'channelIndex': number;
    'qualityDetail': number;
}

export class AbstractMmpValues {
    'dataType': MmpValueType;
}

export class AnalogModuleValues {
    'moduleIndex': number;
    /**
    * An array of objects containing analog values and quality error flags. The index of the channel matches the index in the array.
    */
    'channelValues': Array<AnalogModuleValuesChannelValues>;
}

export class AnalogModuleValuesChannelValues {
    /**
    * The current value of the analog channel.
    */
    'value': number;
    /**
    * 
    */
    'qualityError': boolean;
}

export class BooleanValue {
    'value': boolean;
}

/**
* 
*/
export class ChannelConfig {
    'moduleType': number;
    'channelType': number;
    /**
    * The index of the module, between 0 and 15.
    */
    'moduleIndex': number;
    /**
    * The index of the channel, between 0 and one less than the number of channels on the current module.
    */
    'channelIndex': number;
    'name': string;
    'watchdogValue': number;
    'watchdogEnabled': boolean;
    'qualityEnabled': boolean;
    /**
    * [Digital Only]
    */
    'feature': number;
    /**
    * [Analog Only]
    */
    'unit': string;
    /**
    * [Analog Only]
    */
    'offset': number;
    /**
    * [Analog Only]
    */
    'gain': number;
    /**
    * [Analog Only]
    */
    'scaledLower': number;
    /**
    * [Analog Only]
    */
    'scaledUpper': number;
    /**
    * [Analog Only]
    */
    'clampLower': number;
    /**
    * [Analog Only]
    */
    'clampUpper': number;
    /**
    * [Analog Only]
    */
    'averageFilterWeight': number;
    /**
    * [Analog Only]
    */
    'simpleMovingAverageReadings': number;
    /**
    * [Analog Only, Since Firmware 1.3.0]
    */
    'steinhartHartCoefficientA': number;
    /**
    * [Analog Only, Since Firmware 1.3.0]
    */
    'steinhartHartCoefficientB': number;
    /**
    * [Analog Only, Since Firmware 1.3.0]
    */
    'steinhartHartCoefficientSecondOrder': number;
    /**
    * [Analog Only, Since Firmware 1.3.0]
    */
    'steinhartHartCoefficientC': number;
}

export class ChannelConfigWrite {
    'name'?: string;
    'watchdogValue'?: number;
    'watchdogEnabled'?: boolean;
    /**
    * Only used for digital.
    */
    'feature'?: number;
    /**
    * Only used for analog. Must be in hexadecimal format.
    */
    'channelType'?: string;
    /**
    * user-provided unit string.
    */
    'unit'?: string;
    /**
    * Only used for analog.
    */
    'qualityEnabled'?: boolean;
    /**
    * Only used for analog.
    */
    'offset'?: number;
    /**
    * Only used for analog.
    */
    'gain'?: number;
    /**
    * Only used for analog.
    */
    'scaledLower'?: number;
    /**
    * Only used for analog.
    */
    'scaledUpper'?: number;
    /**
    * Only used for analog.
    */
    'clampLower'?: number;
    /**
    * Only used for analog.
    */
    'clampUpper'?: number;
    /**
    * Only used for analog.
    */
    'averageFilterWeight'?: number;
    /**
    * Only used for analog.
    */
    'simpleMovingAverageReadings'?: number;
    /**
    * Only used for analog. Since firmware 1.3.0.
    */
    'steinhartHartCoefficientA'?: number;
    /**
    * Only used for analog. Since firmware 1.3.0.
    */
    'steinhartHartCoefficientB'?: number;
    /**
    * Only used for analog. Since firmware 1.3.0.
    */
    'steinhartHartCoefficientSecondOrder'?: number;
    /**
    * Only used for analog. Since firmware 1.3.0.
    */
    'steinhartHartCoefficientC'?: number;
}

export class ChannelDescription {
    /**
    * A string version of the hexadecimal value of the Channel Type. Each channel type has a unique ID, which is a 32-bit unsigned number. For example, \"0x60000002\".
    */
    'channelTypeId': string;
    /**
    * The name of the __Channel Type__. For example, \"Â±1200mV\".
    */
    'name': I18nString;
    /**
    * The default Engineering Units. For example, \"mV\".
    */
    'engineeringUnits'?: string;
    /**
    * Minimum signal amplitude this channel type can measure or output.
    */
    'minUnderScale'?: number;
    /**
    * Maximum signal amplitude this channel type can measure or output.
    */
    'maxOverScale'?: number;
    /**
    * Low end of published range of signal amplitude for this channel type.
    */
    'lowScale'?: number;
    /**
    * High end of published range of signal amplitude for this channel type.
    */
    'highScale'?: number;
}

/**
* An object map of Channel Descriptions. The property name for each item in the object is the _channelTypeId_ for the Channel Description.
*/
export class ChannelDescriptions extends null<String, ChannelDescription> {
}

/**
* An array of the user-defined channel names of a particular module.
*/
export class ChannelNames {
    /**
    * An array of strings containing channel names. The index of the channel matches the index in the array.
    */
    'names': Array<string>;
}

export class DigitalModuleValues {
    /**
    * The module index.
    */
    'moduleIndex': number;
    /**
    * An array of objects containing digital states and quality error flags. The index of the channel matches the index in the array.
    */
    'channelValues': Array<DigitalModuleValuesChannelValues>;
}

export class DigitalModuleValuesChannelValues {
    /**
    * 
    */
    'state': boolean;
    /**
    * 
    */
    'onLatch': boolean;
    /**
    * 
    */
    'offLatch': boolean;
    'qualityError': boolean;
}

export class FileAreaType {
}

export class FileDetailsArray extends Array<FileDetailsModel> {
}

export class FileDetailsModel {
    /**
    * 
    */
    'name': string;
    /**
    * 
    */
    'path': string;
    /**
    * 
    */
    'modified': number;
    /**
    * 
    */
    'size': number;
}

export class I18nString {
    /**
    * The English version of the text.
    */
    'en': string;
}

export class InlineResponse200 {
    /**
    * An array of ModuleInfo objects describing the modules on a rack. The array index matches the module index on the rack.
    */
    'modules': Array<ModuleInfo>;
}

export class IoConfiguration {
    /**
    * The watchdog time in milliseconds. 0 disables the watchdog. This is the amount of time the I/O unit will wait for communication from the host device before timing out.
    */
    'watchdogMs': number;
    /**
    * Flag for controlling the unit used for temperature inputs.   - 0 = degrees C - non-0 = degrees F 
    */
    'degreesF': boolean;
    /**
    * Format of floating-point values for Modbus.  - 0 for Big Endian. - 1 for Big Endian, word swapped. Most significant bit of float is in the most significant register. 
    */
    'modbusFloatFormat': number;
}

/**
* Version information about the I/O server.
*/
export class IoFirmare {
    /**
    * Version of I/O server.
    */
    'version': string;
    /**
    * Date that the I/O server was built. For example, \"06/08/2018\".
    */
    'date': string;
    /**
    * Time that the I/O server was built. For example, \"08:58:38\".
    */
    'time': string;
}

/**
* Version information about the I/O hardware.
*/
export class IoHardware {
    /**
    * The part name of the hardware. For example, \"GRV-EPIC-PR1\".
    */
    'part': string;
    /**
    * The date of the hardwre design revision. For example, \"05/31/2018\".
    */
    'revision': string;
}

export class IoInfo {
    /**
    * Memory Map revision number.
    */
    'mmpRev': number;
    /**
    * Powerup Clear flag. (0 = OK; anything else means a Powerup Clear is needed)
    */
    'pucFlag': boolean;
    'firmware': IoFirmare;
    'hardware': IoHardware;
}

/**
* A list of MMP values of any type.
*/
export class MmpGenericValues {
    'values': Array<MmpGenericValuesValues>;
    /**
    * One of 'ascii' or 'utf8'. This is how the raw memory will be interpreted.
    */
    'encoding'?: string;
}

export class MmpGenericValuesValues {
    /**
    * String version of the MMP address. Can be either decimal or hexadecimal.
    */
    'address': string;
    'stringValue'?: string;
    /**
    * Float values are returned as doubles. Float values may also be a string type, with a value of either 'NaN', 'Infinity', or '-Infinity'.
    */
    'numberValue'?: number;
    'type': MmpValueType;
}

export class MmpNumericValue {
    'value': number;
    'type'?: MmpValueType;
}

export class MmpValueType {
}

export class ModuleChannelConfig {
    'index': number;
    'typeID': string;
    'typeName': string;
    'channels': Array<ChannelConfig>;
}

export class ModuleChannelDescriptions {
    'channelTypes': Array<string>;
    'defaultChannelType': string;
}

export class ModuleDescription {
    /**
    * Version of schema used for this module description. For example, \"2.0.1\".
    */
    'schemaVersion': string;
    /**
    * Version of the content in this module description. For example, \"1.1.2\".
    */
    'contentVersion': string;
    /**
    * 
    */
    'moduleId': string;
    /**
    * Opto 22 part number for this product. Format for Groov modules is GRV-<signal type>-<num channels>-<other properties>
    */
    'productNumber': string;
    /**
    * Number of channels on this module.
    */
    'numberOfChannels': number;
    /**
    * Brief product description.
    */
    'productDescription': I18nString;
    /**
    * Specifies the channelTypes that are supported by each channel on this module. The channel can be configured to function as a particular channel type by configuring it with the channel type ID of that type.
    */
    'channelDescriptions': ModuleChannelDescriptions;
    /**
    * A localized and ordered list of key-value pairs that may rendered as a specification table in a document or user interface.
    */
    'productSpecification': { [key: string]: { [key: string]: any; }; };
}

/**
* A collection of Modules Descriptions. The property name for each item in the object is the _moduleId_ for the Module Description.
*/
export class ModuleDescriptions extends null<String, ModuleDescription> {
}

export class ModuleInfo {
    /**
    * The module index.
    */
    'index': number;
    /**
    * For example, \"0x94000019\". Will be \"0x00000000\" if no module is plugged in.
    */
    'moduleId': string;
    /**
    * 
    */
    'firmwareMode'?: number;
    /**
    * The unique serial number of the module. For example, 728410.
    */
    'mfgSerialNumber'?: number;
    /**
    * YYYY-MM-DD format. For example, \"2016-3-1\".
    */
    'hardwareRevisionDate'?: string;
    /**
    * For example, \"37672\".
    */
    'loaderProgramNumber'?: string;
    /**
    * \"YYYY-MM-DD\" format. For example, \"2016-05-30\".
    */
    'loaderDate'?: string;
    /**
    * \"HH:MM:SS\" format. For example, \"14:46:03\".
    */
    'loaderTime'?: string;
    /**
    * \"AM.ma\" format. For example, \"R1.0g\".
    */
    'loaderVersion'?: string;
    /**
    * For example, \"0\".
    */
    'firmwareProgramNumber'?: string;
    /**
    * \"YYYY-MM-DD\" format. For example, \"2016-05-30\".
    */
    'firmwareDate'?: string;
    /**
    * \"HH:MM:SS\" format. For example, \"14:46:03\".
    */
    'firmwareTime'?: string;
    /**
    * \"AM.ma\" format. For example, \"R1.0g\".
    */
    'firmwareVersion'?: string;
}

export class ModuleQualityFlags {
    /**
    * A bitmask for module quality. A bit will be set if any channel on the corresponding module has an error condition. A bit will also be set if a module is not present in the corresponding slot on the rack.
    */
    'qualityMask': number;
}

export class ModuleType {
    /**
    * The module index.
    */
    'index': number;
    /**
    * A string version of the hexadecimal value of the module type ID. Each module type has a unique ID, which is a 32-bit unsigned number. For example, \"0x5000000F\" for GRV-IAC-24. If no module is plugged into a slot, then \"id\" will be \"0x00000000\".
    */
    'type': string;
    /**
    * The name of the module, or an empty string if a module is not plugged into the slot. For example, \"GRV-IAC-24\".
    */
    'name': string;
}

export class ModuleTypes {
    /**
    * An array of modules on the rack. The array index matches the module index on the rack.
    */
    'types': Array<ModuleType>;
}

export class NumericValue {
    'value': number;
}

export class RequestError {
    'error': RequestErrorDetail;
}

export class RequestErrorDetail {
    /**
    * A human-readable message describing the error. The message is not fixed and might change without notice.
    */
    'message': string;
}

export class ResponseError {
    'error': ResponseErrorDetail;
}

export class ResponseErrorDetail {
    /**
    * The unique error code for this error.   - 1: General Error - 2: Validation - 3: Timeout - 4: Not Connected to service or device. - 5: Operation Busy. Only one instance of the operation may be running at a time. - 6: MMP Error. See \"subCode\" field for additional error code. 
    */
    'code': number;
    /**
    * An additional error code for this error.  __MMP Errors (_code_ is 6):__ - 5: TransactionLabelMismatch - 57345 (0xE001): Undefined Command - 57346 (0xE002): Invalid Point Type - 57349 (0xE005): Invalid memory address or invalid data for the memory address. 
    */
    'subCode'?: number;
    /**
    * A human-readable message describing the error. The message is not fixed and might change without notice.
    */
    'message': string;
}

export class ValidationError {
    'error': ValidationErrorDetail;
}

export class ValidationErrorDetail {
    /**
    * The unique error code for this error. For validation errors, the error code is 2.
    */
    'code': number;
    /**
    * A human-readable message describing the error. The message is not fixed and might change without notice.
    */
    'message': string;
    /**
    * List of fields that did not validate.
    */
    'fields': Array<string>;
}

export class AnalogChannelRead extends AbstractChannelRead {
    'value': number;
    'minValue': number;
    'maxValue': number;
}

export class DigitalChannelRead extends AbstractChannelRead {
    'state': boolean;
    'onLatchState': boolean;
    'offLatchState': boolean;
    'featureType': number;
    'featureValue': number;
    'counterActive': boolean;
}

export class MmpNumericValues extends AbstractMmpValues {
    'mmpValues'?: Array<number>;
}

export class MmpStringValues extends AbstractMmpValues {
    'mmpValues'?: Array<string>;
}



export enum DefaultApiApiKeys {
    apiKey,
}

export class DefaultApi {
    protected address: string;
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;
    protected apiKey: string;
    protected publicCertFile: Buffer;
    protected caCertFile: Buffer;
    protected isLocalhost: boolean;
    protected httpsAgent: https.Agent = new https.Agent({
        keepAlive: true,
        maxSockets: 1, // might not be needed anymore, since we now use MessageQueue.,
        // port: this.port
        //, ciphers: 'RSA:!EXPORT:!eNULL:!SSLv2' // for sniffing in Wireshark with private key installed
    });;


    protected authentications = {
    }

    constructor(address: string, apiKey: string, publicCertFile: Buffer, caCertFile: Buffer) {
        this.address = address;
        this._basePath = 'https://' + address + '/manage';
        this.apiKey = apiKey;
        this.publicCertFile = publicCertFile;
        this.caCertFile = caCertFile;

        if (address === 'localhost') {
            this.isLocalhost = true;
        }

        this.defaultHeaders['apiKey'] = this.apiKey;
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    /**
     * Add a new file (up to 20M) or update an existing file with the same name.
     * @param area &#39;unsecured&#39; or &#39;secured&#39;
     * @param fileName 
     * @param file 
     * @param {*} [options] Override http request options.
     */
    public addFile(area: string, fileName: string, file: Buffer, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/files/{area}/content/{fileName}'
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)))
            .replace('{' + 'fileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling addFile.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling addFile.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling addFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clear the analog channel's maximum value.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public clearAnalogChannelMaxValue(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/analog/max-value/clear'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling clearAnalogChannelMaxValue.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling clearAnalogChannelMaxValue.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling clearAnalogChannelMaxValue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clear the analog channel's minimum value.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public clearAnalogChannelMinValue(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/analog/min-value/clear'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling clearAnalogChannelMinValue.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling clearAnalogChannelMinValue.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling clearAnalogChannelMinValue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clears the digital channel feature and restarts the measurement.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public clearDigitalChannelFeature(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/digital/feature/clear'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling clearDigitalChannelFeature.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling clearDigitalChannelFeature.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling clearDigitalChannelFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clears the off-latch of the digital channel.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public clearDigitalChannelOffLatch(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/digital/off-latch/clear'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling clearDigitalChannelOffLatch.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling clearDigitalChannelOffLatch.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling clearDigitalChannelOffLatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clears the on-latch of the digital channel.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public clearDigitalChannelOnLatch(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/digital/on-latch/clear'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling clearDigitalChannelOnLatch.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling clearDigitalChannelOnLatch.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling clearDigitalChannelOnLatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a file.
     * @param area &#39;unsecured&#39; or &#39;secured&#39;
     * @param fileName 
     * @param {*} [options] Override http request options.
     */
    public deleteFile(area: string, fileName: string, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/files/{area}/content/{fileName}'
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)))
            .replace('{' + 'fileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling deleteFile.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling deleteFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the current status of the analog fields for the given channel.  Does not confirm that an analog module is plugged in at the given index. 
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public getChannelAnalogStatus(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: AnalogChannelRead; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/analog/status'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getChannelAnalogStatus.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getChannelAnalogStatus.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling getChannelAnalogStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnalogChannelRead; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public getChannelConfiguration(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: ChannelConfig; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/config'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getChannelConfiguration.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getChannelConfiguration.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling getChannelConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChannelConfig; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the Channel Description for the given Channel Type ID.
     * @param channelId A string of the hexadecimal value for the Channel Type ID. For example, \&quot;0x60000002\&quot;.
     * @param {*} [options] Override http request options.
     */
    public getChannelDescription(channelId: string, options: any = {}): Promise<{ response: http.ClientResponse; body: ChannelDescription; }> {
        const localVarPath = this.basePath + '/api/v1/io/descriptions/channels/{channelId}'
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling getChannelDescription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChannelDescription; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns all Channel Descriptions.
     * @param {*} [options] Override http request options.
     */
    public getChannelDescriptions(options: any = {}): Promise<{ response: http.ClientResponse; body: ChannelDescriptions; }> {
        const localVarPath = this.basePath + '/api/v1/io/descriptions/channels';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChannelDescriptions; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the current status of the digital fields for the given channel.\\ Does not confirm that a digital module is plugged in at the given index.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param {*} [options] Override http request options.
     */
    public getChannelDigitalStatus(device: string, moduleIndex: number, channelIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: DigitalChannelRead; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/digital/status'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getChannelDigitalStatus.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getChannelDigitalStatus.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling getChannelDigitalStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DigitalChannelRead; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the channel names for the given module.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param {*} [options] Override http request options.
     */
    public getChannelNames(device: string, moduleIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: ChannelNames; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/names'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getChannelNames.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getChannelNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChannelNames; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Download a file.
     * @param area &#39;unsecured&#39; or &#39;secured&#39;
     * @param fileName 
     * @param {*} [options] Override http request options.
     */
    public getFile(area: string, fileName: string, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/files/{area}/content/{fileName}'
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)))
            .replace('{' + 'fileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling getFile.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get file details.
     * @param area &#39;unsecured&#39; or &#39;secured&#39;
     * @param fileName 
     * @param {*} [options] Override http request options.
     */
    public getFileInfo(area: string, fileName: string, options: any = {}): Promise<{ response: http.ClientResponse; body: FileDetailsModel; }> {
        const localVarPath = this.basePath + '/api/v1/files/{area}/info/{fileName}'
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)))
            .replace('{' + 'fileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling getFileInfo.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getFileInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FileDetailsModel; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List files.
     * @param area &#39;unsecured&#39; or &#39;secured&#39;
     * @param {*} [options] Override http request options.
     */
    public getFiles(area: string, options: any = {}): Promise<{ response: http.ClientResponse; body: FileDetailsArray; }> {
        const localVarPath = this.basePath + '/api/v1/files/{area}/info'
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling getFiles.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FileDetailsArray; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the I/O Unit configuration. These are settings that affect all of the I/O modules and channels.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param {*} [options] Override http request options.
     */
    public getIoConfiguration(device: string, options: any = {}): Promise<{ response: http.ClientResponse; body: IoConfiguration; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/config'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getIoConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IoConfiguration; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns information about the I/O unit.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param {*} [options] Override http request options.
     */
    public getIoInfo(device: string, options: any = {}): Promise<{ response: http.ClientResponse; body: IoInfo; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/info'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getIoInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IoInfo; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the value at the given OptoMMP memory map address.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param address A hexadecimal address. For example, \&quot;0xF0D81100\&quot;.
     * @param type One of &#39;int8&#39;, &#39;uint8&#39;, &#39;int32&#39;, &#39;uint32&#39;, &#39;float&#39;, &#39;string&#39;. This is how the raw memory will be interpreted.
     * @param length For numbers, this is the number of elements to return. It must be 256 or less. For a string, this is the number of bytes to read, and must be 1024 or less.
     * @param encoding One of &#39;ascii&#39; or &#39;utf8&#39;. This is how the raw memory will be interpreted.
     * @param {*} [options] Override http request options.
     */
    public getMmpValues(device: string, address: string, type?: string, length?: number, encoding?: string, options: any = {}): Promise<{ response: http.ClientResponse; body: AbstractMmpValues; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/mmp/address/{address}'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getMmpValues.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getMmpValues.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = type;
        }

        if (length !== undefined) {
            localVarQueryParameters['length'] = length;
        }

        if (encoding !== undefined) {
            localVarQueryParameters['encoding'] = encoding;
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AbstractMmpValues; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns all the channel values of an analog module. This is the most efficient way to get all the analog values. It uses a packed area of the I/O memory map. Additional information about a channel is available on a channel by channel basis.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param {*} [options] Override http request options.
     */
    public getModuleAnalogChannelValues(device: string, moduleIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: AnalogModuleValues; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/analog/values'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleAnalogChannelValues.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getModuleAnalogChannelValues.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnalogModuleValues; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the configuration for the given module.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param {*} [options] Override http request options.
     */
    public getModuleConfiguration(device: string, moduleIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: ModuleChannelConfig; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/config'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleConfiguration.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getModuleConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleChannelConfig; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the Module Description for the given module ID or product number.
     * @param module The module ID (e.g. \&quot;0x90000014\&quot;) or module product number (e.g. \&quot;GRV-OAC-12-I\&quot;).
     * @param {*} [options] Override http request options.
     */
    public getModuleDescription(module: string, options: any = {}): Promise<{ response: http.ClientResponse; body: ModuleDescription; }> {
        const localVarPath = this.basePath + '/api/v1/io/descriptions/modules/{module}'
            .replace('{' + 'module' + '}', encodeURIComponent(String(module)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'module' is not null or undefined
        if (module === null || module === undefined) {
            throw new Error('Required parameter module was null or undefined when calling getModuleDescription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleDescription; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns all Module Descriptions.
     * @param {*} [options] Override http request options.
     */
    public getModuleDescriptions(options: any = {}): Promise<{ response: http.ClientResponse; body: ModuleDescriptions; }> {
        const localVarPath = this.basePath + '/api/v1/io/descriptions/modules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleDescriptions; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns all the channel values of a digital module. This is the most efficient way to get all the digital values. It uses a packed area of the I/O memory map. Additional information about a channel is available on a channel by channel basis.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param {*} [options] Override http request options.
     */
    public getModuleDigitalChannelValues(device: string, moduleIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: DigitalModuleValues; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/digital/values'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleDigitalChannelValues.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getModuleDigitalChannelValues.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DigitalModuleValues; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns information about the module at the given slot index.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param {*} [options] Override http request options.
     */
    public getModuleInfo(device: string, moduleIndex: number, options: any = {}): Promise<{ response: http.ClientResponse; body: ModuleInfo; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/info'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleInfo.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling getModuleInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleInfo; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns information about all the modules plugged into the rack.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param {*} [options] Override http request options.
     */
    public getModuleInfos(device: string, options: any = {}): Promise<{ response: http.ClientResponse; body: InlineResponse200; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/info'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleInfos.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns quality flags for all the module slots on the rack.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param {*} [options] Override http request options.
     */
    public getModuleQualityFlags(device: string, options: any = {}): Promise<{ response: http.ClientResponse; body: ModuleQualityFlags; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/quality'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleQualityFlags.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleQualityFlags; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns all the types of modules plugged into the rack.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param {*} [options] Override http request options.
     */
    public getModuleTypes(device: string, options: any = {}): Promise<{ response: http.ClientResponse; body: ModuleTypes; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/type'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling getModuleTypes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleTypes; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the value of the analog channel.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param body The value for the channel.
     * @param {*} [options] Override http request options.
     */
    public setAnalogChannelValue(device: string, moduleIndex: number, channelIndex: number, body: NumericValue, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/analog/value'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setAnalogChannelValue.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling setAnalogChannelValue.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling setAnalogChannelValue.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setAnalogChannelValue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public setChannelConfiguration(device: string, moduleIndex: number, channelIndex: number, body: ChannelConfigWrite, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/config'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setChannelConfiguration.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling setChannelConfiguration.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling setChannelConfiguration.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setChannelConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Activates or deactivates a digital channel counter. Has no affect on other digital input features.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param body The state for the channel.
     * @param {*} [options] Override http request options.
     */
    public setDigitalChannelCounterActive(device: string, moduleIndex: number, channelIndex: number, body: BooleanValue, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/digital/counter/active'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setDigitalChannelCounterActive.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling setDigitalChannelCounterActive.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling setDigitalChannelCounterActive.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setDigitalChannelCounterActive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the current state of the digital channel.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param moduleIndex The index of the module, between 0 and 15.
     * @param channelIndex The index of the channel, between 0 and one less than the number of channels on the current module.
     * @param body The state for the channel.
     * @param {*} [options] Override http request options.
     */
    public setDigitalChannelState(device: string, moduleIndex: number, channelIndex: number, body: BooleanValue, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/modules/{moduleIndex}/channels/{channelIndex}/digital/state'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'moduleIndex' + '}', encodeURIComponent(String(moduleIndex)))
            .replace('{' + 'channelIndex' + '}', encodeURIComponent(String(channelIndex)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setDigitalChannelState.');
        }

        // verify required parameter 'moduleIndex' is not null or undefined
        if (moduleIndex === null || moduleIndex === undefined) {
            throw new Error('Required parameter moduleIndex was null or undefined when calling setDigitalChannelState.');
        }

        // verify required parameter 'channelIndex' is not null or undefined
        if (channelIndex === null || channelIndex === undefined) {
            throw new Error('Required parameter channelIndex was null or undefined when calling setDigitalChannelState.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setDigitalChannelState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public setIoConfiguration(device: string, body: IoConfiguration, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/config'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setIoConfiguration.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setIoConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send an Operation Code to the I/O unit.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public setIoConfigurationOpCode(device: string, body: NumericValue, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/config/opcode'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setIoConfigurationOpCode.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setIoConfigurationOpCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Writes a value at the given OptoMMP memory map address.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param address A hexadecimal address. For example, \&quot;0xF0D81100\&quot;.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public setMmpValue(device: string, address: string, body: MmpNumericValue, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/mmp/address/{address}'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)))
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setMmpValue.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling setMmpValue.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setMmpValue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Writes to one or more OptoMMP memory map addresses.
     * @param device The name of the device. Use \&quot;local\&quot; for the built-in rack of I/O.
     * @param body An array of values and address to write. The array must have between 1 and 256 elements. Otherwise, 400 is returned.
     * @param {*} [options] Override http request options.
     */
    public setMmpValues(device: string, body: MmpGenericValues, options: any = {}): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/io/{device}/mmp/address'
            .replace('{' + 'device' + '}', encodeURIComponent(String(device)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling setMmpValues.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setMmpValues.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
