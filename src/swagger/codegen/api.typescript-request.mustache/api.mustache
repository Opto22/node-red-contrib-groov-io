{{>licenseInfo}}
import localVarRequest = require('request');
import http = require('http');
import https = require('https');
{{^supportsES6}}
import Promise = require('bluebird');
{{/supportsES6}}

let defaultBasePath = '{{{basePath}}}';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

{{#models}}
{{#model}}
{{#description}}
/**
* {{{description}}}
*/
{{/description}}
export class {{classname}} {{#parent}}extends {{{parent}}} {{/parent}}{
{{#vars}}
{{#description}}
    /**
    * {{{description}}}
    */
{{/description}}
    '{{name}}'{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{datatype}}}{{/isEnum}};
{{/vars}}
}

{{#hasEnums}}
export namespace {{classname}} {
{{#vars}}
{{#isEnum}}
    export enum {{enumName}} {
        {{#allowableValues}}
        {{#enumVars}}
        {{name}} = <any> {{{value}}}{{^-last}},{{/-last}}
        {{/enumVars}}
        {{/allowableValues}}
    }
{{/isEnum}}
{{/vars}}
}
{{/hasEnums}}
{{/model}}
{{/models}}


{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#description}}
/**
* {{&description}}
*/
{{/description}}
export enum {{classname}}ApiKeys {
{{#authMethods}}
{{#isApiKey}}
    {{name}},
{{/isApiKey}}
{{/authMethods}}
}

export class {{classname}} {
    protected address: string;
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;
    protected apiKey: string;
    protected publicCertFile: Buffer;
    protected caCertFile: Buffer;
    protected isLocalhost: boolean;
    protected httpsAgent: https.Agent = new https.Agent({
        keepAlive: true,
        maxSockets: 1, // might not be needed anymore, since we now use MessageQueue.,
        // port: this.port
        //, ciphers: 'RSA:!EXPORT:!eNULL:!SSLv2' // for sniffing in Wireshark with private key installed
    });;


    protected authentications = {
    }

    constructor(address: string, apiKey: string, publicCertFile: Buffer, caCertFile: Buffer) {
        this.address = address;
        this._basePath = 'https://' + address + '/manage';
        this.apiKey = apiKey;
        this.publicCertFile = publicCertFile;
        this.caCertFile = caCertFile;

        if (address === 'localhost') {
            this.isLocalhost = true;
        }

        this.defaultHeaders['apiKey'] = this.apiKey;
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{paramName}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request options.
     */
    public {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options: any = {}): Promise<{ response: http.{{#supportsES6}}IncomingMessage{{/supportsES6}}{{^supportsES6}}ClientResponse{{/supportsES6}}; {{#returnType}}body: {{{returnType}}}; {{/returnType}}{{^returnType}}body?: any; {{/returnType}}}> {
        const localVarPath = this.basePath + '{{{path}}}'{{#pathParams}}
            .replace('{' + '{{baseName}}' + '}', encodeURIComponent(String({{paramName}}))){{/pathParams}};
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

{{#allParams}}
{{#required}}
        // verify required parameter '{{paramName}}' is not null or undefined
        if ({{paramName}} === null || {{paramName}} === undefined) {
            throw new Error('Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
        }

{{/required}}
{{/allParams}}
{{#queryParams}}
        if ({{paramName}} !== undefined) {
            localVarQueryParameters['{{baseName}}'] = {{paramName}};
        }

{{/queryParams}}
{{#headerParams}}
        localVarHeaderParams['{{baseName}}'] = {{paramName}};
{{/headerParams}}
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

{{#formParams}}
        if ({{paramName}} !== undefined) {
            localVarFormParams['{{baseName}}'] = {{paramName}};
        }
{{#isFile}}
        localVarUseFormData = true;
{{/isFile}}

{{/formParams}}
        let localVarRequestOptions: localVarRequest.Options = {
            method: '{{httpMethod}}',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
{{^isResponseFile}}
            json: true,
{{/isResponseFile}}
{{#isResponseFile}}
            encoding: null,
{{/isResponseFile}}
{{#bodyParam}}
            body: {{paramName}}
{{/bodyParam}}
        };

        if (this.publicCertFile) {
            localVarRequestOptions.cert = this.publicCertFile;
        }

        if (this.caCertFile) {
            localVarRequestOptions.ca = this.caCertFile;
        }


        // Local connections do not require certificates for HTTPS.
        if (!this.publicCertFile && !this.caCertFile && this.isLocalhost) {
            (<https.ServerOptions>localVarRequestOptions).rejectUnauthorized = false;
        }

        localVarRequestOptions.forever = true;
        localVarRequestOptions.agent = this.httpsAgent;
        localVarRequestOptions.timeout = 15000;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.{{#supportsES6}}IncomingMessage{{/supportsES6}}{{^supportsES6}}ClientResponse{{/supportsES6}}; {{#returnType}}body: {{{returnType}}}; {{/returnType}}{{^returnType}}body?: any; {{/returnType}}}>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
{{/operation}}
}
{{/operations}}
{{/apis}}
{{/apiInfo}}
